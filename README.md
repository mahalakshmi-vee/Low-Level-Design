# Low-Level Design
   * Low-level design (LLD) is the process of specifying and defining the detailed design of a software system.
   *  It focuses on how the system will be built and how it will function at a detailed level.
   *  This design provides the foundation for high-level design, which defines a system's overall architecture and design.
## Techniques Used to Build Low-Level Design
   1. Object-Oriented Programming (OOP)
   2. SOLID Principles
   3. Design Patterns: Reusable solutions to common problems in software design.
      
          1. Creational Design Patterns
               1. Singleton
               2. Factory Method
               3. Abstract Factory Method
               4. Prototype
               5. Builder
      
          2. Structural Design Patterns
               6. Adapter
               7. Bridge
               8. Composite
               9. Decorator
               10. Facade
               11. Flyweight
               12. Proxy
      
          3. Behavioral Design Patterns
               13. Chain of Responsibility
               14. Command
               15. Iterator
               16. Mediator
               17. Memento
               18. Observer
               19. State
               20. Strategy
               21. Template Method
               22. Visitor
   4. UML Diagrams
   5. Data Structures & Algorithms
   6. Database Design
## Steps Involved in Low-Level Design
   1. Clarify Requirements: Understand the problem you're solving.
   2. Identify Entities: Identify the core entities that will play a role in the system.
   3. Class Design: Create detailed design for the classes and their relationships.
   4. Implementation: Code the design, translating the design into working software.
   5. Exception Handling: Design and implement error handling mechanisms.

## Design Patterns an When to Use Them
| Design Pattern           | When to use   |
| ------------------------ | ------------- |
| Singleton                | When you need to ensure a class has only one instance and provide a global access point.  |
| Factory Method           | When you want to create objects, but allow subclasses to alter the type of objects that will be created.  |
| Abstract Factory Method  | When you need to create families of related or dependent objects without specifying their concrete classes.  |
| Prototype                | When you need to create exact copies of objects without knowing the exact class of the object.  |
| Builder                  | When you need to construct complex objects step by step, especially when objects have many parameters.  |
| Adapter                  | When you need to enable communication between two incompatible interfaces without changing the existing code.  |
| Bridge                   | Content Cell  |
| Composite                | Content Cell  |
| Decorator                | Content Cell  |
| Facade                   | Content Cell  |
| Flyweight                | Content Cell  |
| Proxy                    | Content Cell  |
| Decorator                | Content Cell  |
| Chain of Responsibility  | When you need to pass a request through a chain of handlers, where each handler can process it or pass it on.  |
| Command                  | Content Cell  |
| Iterator                 | Content Cell  |
| Mediator                 | Content Cell  |
| Memento                  | Content Cell  |
| Observer                 | Content Cell  |
| State                    | Content Cell  |
| Strategy                 | When you have multiple algorithms that can be applied to a given task, but you want to choose the most appropriate one dynamically at runtime. |
| Template Method          | Content Cell  |
| Visitor                  | Content Cell  |
